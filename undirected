static XMLNode*
Detector:findXmlNode(XMLNode *node, const char *name)
{
    while (node != NULL) {
        if ((!strcmp(node->value, (const char *)name))) {
            break;
        }
        node = node->FirstChild ();
    }
    return node;
}

static int
write_phrase(char *line, std::ofstream &of, int start, int end)
{
     char *phrase, *brk;
     const char sep[] = "\n\t ";
     int i;

     for (phrase = strtok_r(line, sep, &brk), i = 0; i < start; i++) {
         if (phrase == NULL)
             return -1;

         phrase = strtok_r(NULL, sep, &brk);
     }

     for (; i <= end; i++) {
         if (phrase == NULL)
             return -1;
         of << phrase << " ";
         phrase = strtok_r(NULL, sep, &brk);
     }
     of << "\n";
     return 0;
}

static void
process_elements(xmlDoc *doc, xmlNode *root_node, std::ofstream &of)
{
    XMLNode *cascade_node, *node, *stages_node, *underscore_node;
    XMLNode *weak_classifiers, *underscore_node_2;
    XMLNode *features_node;
    char *value;
    std::stringstream ss;

    if (strcmp(root_node->value, (const char *) "opencv_storage")) {
        fprintf(stderr,"document of the wrong type, root node != opencv_storage\n");
        return;
    }

    /* find the cascae type */
    cascade_node = root_node->FirstChild ();
    while (cascade_node != NULL) {
        if ((!strcmp(cascade_node->name, (const char *)"cascade"))) {
            break;
        }
        cascade_node = cascade_node->FirstChild ();
    }
    if (cascade_node == NULL) {
        fprintf(stderr,"Cannot find cascade\n");
        return;
    }

    node = find_node(cascade_node->FirstChild (), "height");
    if (node == NULL) {
        fprintf(stderr,"Cannot find height\n");
        return;
    }
    value = xmlNodeListGetString(doc, node->children, 1);
    of << value << "\n";
    xmlFree(value);

    node = find_node(cascade_node->children, "width");
    if (node == NULL) {
        fprintf(stderr,"Cannot find width\n");
        return;
    }
    value = xmlNodeListGetString(doc, node->children, 1);
    of << value << "\n";
    xmlFree(value);

    node = find_node(cascade_node->children, "stageNum");
    if (node == NULL) {
        fprintf(stderr,"Cannot find stageNum\n");
        return;
    }
    value = xmlNodeListGetString(doc, node->children, 1);
    of << value << "\n";
    xmlFree(value);

    stages_node = find_node(cascade_node->children, "stages");
    if (node == NULL) {
        fprintf(stderr,"Cannot find stages\n");
        return;
    }
    underscore_node = stages_node->children;
    while (underscore_node) {
        if ((strcmp(underscore_node->name, (const char *)"_"))) {
            underscore_node = underscore_node->next;
            continue;
        }
        node = find_node(underscore_node->children, "maxWeakCount");
        if (node == NULL) {
            fprintf(stderr,"Cannot find maxWeakCount\n");
            return;
        }
        value = xmlNodeListGetString(doc, node->children, 1);
        of << value << "\n";
        xmlFree(value);

        node = find_node(underscore_node->children, "stageThreshold");
        if (node == NULL) {
            fprintf(stderr,"Cannot find stageThreshold\n");
            return;
        }
        value = xmlNodeListGetString(doc, node->children, 1);
        of << value << "\n";
        xmlFree(value);

        /* features */
        weak_classifiers = find_node(underscore_node->children, "weakClassifiers");
        if (weak_classifiers == NULL) {
            fprintf(stderr,"Cannot find weakClassifiers\n");
            return;
        }

        underscore_node_2 = weak_classifiers->children;
        while (underscore_node_2) {
            int ret;
            if ((strcmp(underscore_node_2->name, (const char *)"_"))) {
                underscore_node_2 = underscore_node_2->next;
                continue;
            }
            node = find_node(underscore_node_2->children, "internalNodes");
            if (node == NULL) {
                fprintf(stderr,"Cannot find internalNodes\n");
                return;
            }
            value = xmlNodeListGetString(doc, node->children, 1);
            ret = write_phrase((char *)value, of, 2, 10);
            if (ret) {
                fprintf(stderr,"error parsing internalNodes\n");
                return;
            }
            xmlFree(value);

            node = find_node(underscore_node_2->children, "leafValues");
            if (node == NULL) {
                fprintf(stderr,"Cannot find leafValues\n");
                return;
            }
            value = xmlNodeListGetString(doc, node->children, 1);
            ret = write_phrase((char *)value, of, 0, 1);
            if (ret) {
                fprintf(stderr,"error parsing leafValues\n");
                return;
            }
            xmlFree(value);
            underscore_node_2 = underscore_node_2->next;
        }

        underscore_node = underscore_node->next;
    }
    features_node = find_node(cascade_node->children, "features");
    if (node == NULL) {
        fprintf(stderr,"Cannot find features\n");
        return;
    }
    /* count how many features */
    underscore_node = features_node->children;
    int features = 0;
    while (underscore_node) {
        if ((strcmp(underscore_node->name, (const char *)"_"))) {
            underscore_node = underscore_node->next;
            continue;
        }
        node = find_node(underscore_node->children, "rect");
        if (node == NULL) {
            fprintf(stderr,"Cannot find rect\n");
            return;
        }
        underscore_node = underscore_node->next;
        features++;
    }
    of << features << "\n";
    underscore_node = features_node->children;
    while (underscore_node) {
        int ret;
        if ((strcmp(underscore_node->name, (const char *)"_"))) {
            underscore_node = underscore_node->next;
            continue;
        }
        node = find_node(underscore_node->children, "rect");
        if (node == NULL) {
            fprintf(stderr,"Cannot find rect\n");
            return;
        }
        value = xmlNodeListGetString(doc, node->children, 1);
        ret = write_phrase((char *)value, of, 0, 3);
        if (ret) {
            fprintf(stderr,"error parsing rect\n");
            return;
        }
        xmlFree(value);

        underscore_node = underscore_node->next;
    }

}
